using System;
using System.Collections.Generic;
using System.Linq;
using Fracture.Engine.Core.Primitives;
using Fracture.Engine.Physics.Dynamics;

namespace Fracture.Engine.Physics.Contacts
{
    /// <summary>
    /// Class that handles broad phase contact solving between
    /// bodies based on their current translation and transformation.
    /// </summary>
    public sealed class BroadPhaseContactSolver
    {
        #region Constant fields
        // Initial capacity of contacts in the solver.
        private const int Capacity = 32;
        #endregion

        #region Fields
        private readonly HashSet<ContactPair> lookup;

        private ContactPair[] pairs;
        #endregion

        #region Properties
        /// <summary>
        /// Returns the count of available
        /// collision pairs generated by the solve 
        /// method.
        /// </summary>
        public int Count
        {
            get;
            private set;
        }
        #endregion

        public BroadPhaseContactSolver()
        {
            lookup = new HashSet<ContactPair>();
            pairs  = new ContactPair[Capacity];
        }

        private bool PairExists(Body a, Body b)
            => lookup.Contains(new ContactPair() { A = a, B = b });

        private void EnqueuePair(Body a, Body b)
        {
            if (Count >= pairs.Length)
                Array.Resize(ref pairs, pairs.Length * 2);

            ref var pair = ref pairs[Count++];

            pair.A = a;
            pair.B = b;
        }

        /// <summary>
        /// Returns next available contact pair.
        /// </summary>
        public ref ContactPair Next()
        {
            ref var pair = ref pairs[--Count];

            lookup.Remove(pair);

            return ref pair;
        }

        private void SolveNode(QuadTreeNode node, float delta)
        {
            if (node.IsSplit)
            {
                SolveNode(node.TopLeft, delta);
                SolveNode(node.TopRight, delta);
                SolveNode(node.BottomRight, delta);
                SolveNode(node.BottomLeft, delta);

                return;
            }

            // Pair all dynamics and statics.
            if (node.Dynamics.Any() && node.Statics.Any())
            {
                foreach (var db in node.Dynamics)
                {
                    // If not transformation or translation is being applied to the body,
                    // we can skip bounding volume checks thus eliminating pairing.
                    if (!db.Active)
                        continue;
                    
                    var dba = db.TransformBoundingBox;

                    foreach (var sb in node.Statics)
                    {
                        // Does the pair already exist.
                        if (PairExists(db, sb))
                            continue;

                        // If bounding volumes do not intersect, we can skip
                        // rest of the checks.
                        if (!Aabb.Intersects(sb.BoundingBox, dba))
                            continue;

                        // These bodies bounding volumes intersect so
                        // we queue them for narrow phase check.
                        EnqueuePair(db, sb);
                    }
                }
            }

            // Pair all sensors and dynamics.
            if (node.Sensors.Any() && node.Dynamics.Any())
            {
                foreach (var sb in node.Sensors)
                {
                    // For sensors, we need to check each time.
                    var sba = sb.TransformBoundingBox;
                    
                    foreach (var db in node.Dynamics)
                    {
                        // Does the pair already exist.
                        if (PairExists(sb, db))
                            continue;

                        // If bounding volumes do not intersect, we can skip
                        // rest of the checks.
                        if (!Aabb.Intersects(db.TransformBoundingBox, sba))
                            continue;

                        // These bodies bounding volumes intersect so
                        // we queue them for narrow phase check.
                        EnqueuePair(sb, db);
                    }
                }
            }
        }
        
        /// <summary>
        /// Does full broad phase contact solving based on 
        /// the configuration of the solver and generates
        /// appropriate collision pairs.
        /// 
        /// TODO: add threading.
        /// </summary>
        public void Solve(QuadTree tree, float delta)
            => SolveNode(tree.Root, delta);
    }
}