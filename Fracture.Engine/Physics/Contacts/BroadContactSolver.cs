using System;
using System.Collections.Generic;
using System.Linq;
using Fracture.Common.Util;
using Fracture.Engine.Core.Primitives;
using Fracture.Engine.Physics.Dynamics;
using Fracture.Engine.Physics.Spatial;

namespace Fracture.Engine.Physics.Contacts
{
    /// <summary>
    /// Class that represents a contact pair which contain
    /// two bodies of interest for checking collision in 
    /// narrow phase. These are generated by the broad 
    /// phase contact solver.
    /// </summary>
    public readonly struct ContactPair
    {
        #region Properties
        /// <summary>
        /// Fist body of interest that could collide with the second body.
        /// </summary>
        public int FirstBodyId
        {
            get;
        }

        /// <summary>
        /// Second body of interest that could collide with the first one.
        /// </summary>
        public int SecondBodyId
        {
            get;
        }
        #endregion

        public ContactPair(int firstBodyId, int secondBodyId)
        {
            FirstBodyId  = firstBodyId;
            SecondBodyId = secondBodyId;
        }

        public bool Equals(in ContactPair other)
            => FirstBodyId == other.FirstBodyId &&
               SecondBodyId == other.SecondBodyId;

        public override bool Equals(object obj)
            => obj is ContactPair other && Equals(other);
            
        public override int GetHashCode()
            => HashUtils.Create()
                        .Append(FirstBodyId)
                        .Append(SecondBodyId);
        public static bool operator ==(in ContactPair lhs, in ContactPair rhs)
            => lhs.Equals(rhs);

        public static bool operator !=(in ContactPair lhs, in ContactPair rhs)
            => !lhs.Equals(rhs);
    }
    
    /// <summary>
    /// Class that handles broad phase contact solving between
    /// bodies based on their current translation and transformation.
    /// </summary>
    public sealed class BroadPhaseContactSolver
    {
        #region Constant fields
        // Initial capacity of contacts in the solver.
        private const int Capacity = 32;
        #endregion

        #region Fields
        private readonly HashSet<ContactPair> lookup;

        private ContactPair[] pairs;
        #endregion

        #region Properties
        /// <summary>
        /// Returns the count of available
        /// collision pairs generated by the solve 
        /// method.
        /// </summary>
        public int Count
        {
            get;
            private set;
        }
        #endregion

        public BroadPhaseContactSolver()
        {
            lookup = new HashSet<ContactPair>();
            pairs  = new ContactPair[Capacity];
        }

        private bool PairExists(int firstBodyId, int secondBodyId)
            => lookup.Contains(new ContactPair(firstBodyId, secondBodyId));

        private void EnqueuePair(int firstBodyId, int secondBodyId)
        {
            if (Count >= pairs.Length)
                Array.Resize(ref pairs, pairs.Length * 2);

            pairs[Count++] = new ContactPair(firstBodyId, secondBodyId);
            
            lookup.Add(new ContactPair(firstBodyId, secondBodyId));
        }

        /// <summary>
        /// Returns next available contact pair.
        /// </summary>
        public ref ContactPair Next()
        {
            ref var pair = ref pairs[--Count];

            lookup.Remove(pair);

            return ref pair;
        }

        private void Solve(QuadTreeNode node, BodyList bodies)
        {
            if (node.IsSplit)
            {
                Solve(node.TopLeft, bodies);
                Solve(node.TopRight, bodies);
                Solve(node.BottomRight, bodies);
                Solve(node.BottomLeft, bodies);

                return;
            }

            // Pair all dynamics and statics.
            if (node.Dynamics.Any() && node.Statics.Any())
            {
                foreach (var dynamicBodyId in node.Dynamics)
                {
                    // If not transformation or translation is being applied to the body,
                    // we can skip bounding volume checks thus eliminating pairing.
                    ref var dynamicBody = ref bodies.WithId(dynamicBodyId);

                    if (!dynamicBody.IsActive())
                        continue;
                    
                    foreach (var staticBodyId in node.Statics)
                    {
                        // Does the pair already exist.
                        if (PairExists(dynamicBodyId, staticBodyId))
                            continue;

                        // If bounding volumes do not intersect, we can skip
                        // rest of the checks.
                        ref var staticBody = ref bodies.WithId(staticBodyId);
                        
                        if (!Aabb.Intersects(dynamicBody.BoundingBox, staticBody.BoundingBox))
                            continue;

                        // These bodies bounding volumes intersect so
                        // we queue them for narrow phase check.
                        EnqueuePair(dynamicBodyId, staticBodyId);
                    }
                }
            }

            // Pair all sensors and dynamics.
            if (node.Sensors.Any() || node.Dynamics.Any())
            {
                foreach (var sensorBodyId in node.Sensors)
                {
                    // For sensors, we need to check each time.
                    ref var sensorBody = ref bodies.WithId(sensorBodyId);
                        
                    foreach (var dynamicBodyId in node.Dynamics)
                    {
                        // Does the pair already exist.
                        ref var dynamicBody = ref bodies.WithId(dynamicBodyId);
                        
                        if (PairExists(sensorBodyId, dynamicBodyId))
                            continue;

                        // If bounding volumes do not intersect, we can skip
                        // rest of the checks.
                        if (!Aabb.Intersects(sensorBody.BoundingBox, dynamicBody.BoundingBox))
                            continue;

                        // These bodies bounding volumes intersect so
                        // we queue them for narrow phase check.
                        EnqueuePair(sensorBodyId, dynamicBodyId);
                    }
                }
            }
            
            // Pair all sensors.
            if (!node.Sensors.Any())
                return;

            foreach (var firstSensorId in node.Sensors)
            {
                foreach (var secondSensorId in node.Sensors)
                {
                    if (firstSensorId == secondSensorId)
                        continue;
                    
                    if (PairExists(firstSensorId, secondSensorId))
                        continue;
                    
                    ref var firstSensorBody  = ref bodies.WithId(firstSensorId);
                    ref var secondSensorBody = ref bodies.WithId(secondSensorId);
                    
                    if (!Aabb.Intersects(firstSensorBody.BoundingBox, secondSensorBody.BoundingBox))
                        continue;
                    
                    EnqueuePair(firstSensorId, secondSensorId);
                }
            }
        }
        
        /// <summary>
        /// Does full broad phase contact solving based on 
        /// the configuration of the solver and generates
        /// appropriate collision pairs.
        /// 
        /// TODO: add threading.
        /// </summary>
        public void Solve(QuadTree tree, BodyList bodies)
            => Solve(tree.Root, bodies);
    }
}